# 3.Vue全家桶

## ⚽️第一部分：Vue-Cli

> [Vue-Cli...](https://cli.vuejs.org/zh/guide/cli-service.html)

### 1.安装脚手架和使用

- npm i -g @vue/cli 安装脚手架，用于生成项目
- npm i -g @vue/cli-service-global 快速原型开发，编译.vue文件
- 直接使用编译.vue文件: vue serve app.vue

**使用Cli生成：vue create 名称**

```sh
# Cli选择配置

default（babel, eslint） # 默认配置
Manually select features # 自定义配置

# 自定义配置
Babel # 启动Babel
Typescript # 支持Typescript
Progressive Web App（PWA）Support # PWA
Router # 路由
Vuex # 状态管理
CSS Pre-processors # CSS预处理器
Lintor / Formattor # 
Lint Testing # 
E2E Testing # E2E 测试

Where do you prefer placing config for ... # 文件放到哪里
In deficated config files # 单独成一个文件
In package.json # 放到 package.json 里面

Save this as a preset for futrue projects？ # 是否保留预设给未来使用

```

---

### 2.目录介绍

**基础目录**

- publice（静态文件）
- src（源文件）
    - assets（静态资源）
    - components（组件）
    - App.vue
    - main.js 入口文件

**拓展目录**

- src
    - assets（静态资源）
    - components（组件）
    - views（页面级组件）
    - router（路由文件）
    - vuex（Vuex文件）
    - App.vue
    - main.js 入口文件
- vue.config.js Vue-Cli配置文件

---

### 3.Cli配置


---

## 🏀第二部分：Vue-Router

> [Vue-Router官网...](https://router.vuejs.org/zh/)

### 1.安装和使用

- 要不就是 vue create 项目名称的时候，选上vue-router（推荐）
- 要不就是 vue add router
- 要不就是 npm 下载，然后自己建立文件夹，调整 main.js 

**基本使用**

```js
// router.js
import Vue from 'vue'
import Router from 'vue-router'

Vue.use(Router) // 会往Vue上添加 $router $route

// 路由的作用：在不同的路径，展示不同的内容，下面的配置就是做这个事情
export default new Router({
    routes: [
        {
            path: '/',
            name: 'home',
            // 组件懒加载写法（提高首屏加载）
            component: () => import(/* webpackChunkName: "about" */ './views/Home.vue')
        }
    ]
})

```

---

### 2.router-link && router-view

```html
<router-link to="/">首页</router-link>
<router-link to="{ path: '/' }">首页</router-link>
<!-- 默认渲染成a标签，如果你不想渲染成a标签，可以通过 tag进行设置 -->
<router-link tag="li" to="{ name: 'home' }">首页</router-link>

<!-- 展示跳转的 -->
<router-view></router-view>
```



---

### 3.嵌套路由 && $router

```js
import Router from 'vue-router'
import Vue from 'vue'

Vue.use(Router)

export default new Router({
    routes: [
        {
            path: '/',
            name: ...,
            component: ...,
            redirect: '/login', // 重定向
            children: [
                {
                    path: 'login',
                    name: ...,
                    component: ...
                },
                {
                    path: 'register',
                    name: ...,
                    component: ...
                }
            ]
        },
        {
            path: '*',
            redirect: '/404',
            component: ...
        }
    ]
})

// 在组件中跳转
this.$router.push('/home')
this.$router.replace('/home')

// 跳转效果一样，不一样的地方在于 回退的效果上
// 解释这两个不同，我们先网站路由想象成一个数组，
// [a, b, c] --> this.$router.push('/d') --> [a, b, c, d]
// [a, b, c] --> this.$router.replace('/d') --> [a, b, d]

// this.$router.go()
this.$router.go(0) // 不动
this.$router.go(-1) // 页面往后退
this.$router.go(1) // 页面前进


```

---

### 4.导航守卫 & 动态路由

**全局导航守卫**

```js
const router = new VueRouter({ ... })

router.beforeEach((to, from, next) => {
  // to: 即将要进入的目标 路由对象
  // from: 当前导航正要离开的路由
  // next: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数 | next('/home') 可以改变要进入的路由
})

router.afterEach((to, from) => {
  // ...
})
```

---

**路由导航守卫**

```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

---

**组件导航守卫**

```html
<script>
export default {
    // 路由离开之前
    beforeRouteLeave (to, from, next) {
        // this: 是 组件实例
        // to: 即将要进入的目标 路由对象
        // from: 当前路由所在的一些信息
        // next: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数 | next('/home') 可以改变要进入的路由

        // 常用于填写表单的时候，误触路由跳转
    },
    // 路由进来之前
    beforRouteEnter (to, from, next) {
        // this: 是 undefined（因为路由还未进来）
    }
}
</script>
```

---

### 5.$router & $route

---

### 6.路由元信息


---

## 🏈第三部分：Axios

---

## ⚾️第四部分：Vuex

> [官方网址](https://vuex.vuejs.org/zh/)


### 1.基本使用

处理多组件共享同一数据的情况（跨多组件通信）

- 在Vue-Cli中安装：vue add vue

> 看下面的结构你要明白一点，Vuex 数据不能随便定义（需要定义到state），数据不能直接更改（actions）

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex) // 给Vue注入了一个 $state

export default new Vuex.Store({
    
    // 定义数据的地方
    // 使用：$store.state.name & mapState(['name', 'age'])
    state: {
        name: '朱昆鹏',
        age: 21
    },

    // Vuex的计算属性（我先这么理解吧）
    // 使用：$store.getters.nameAndAge & mapGetters['nameAndAge']
    getters: {
        nameAndAge (state) {
            return `姓名：${state.name} 年龄：${state.age}`
        }
    },

    // 更改数据的地方,立即改变，内部写异步无效
    // $store.commit('ageAdd', 5 参数二也可以写成对象形式
    mutations: {
        ageAdd (state, num) {
            state.age += num
        }
    },

    // 处理异步，异步完成之后调用 mutations，进行改变
    // $store.dispath('ageAdd', 5)
    actions: {
        ageAdd ( {commit}, num ) {
            setTimeout(() => {
                commit('ageAdd', num)
            }, 1000)
        }
    }
})
```

---

### 2.state（单一状态树）

> 就是定义数据的地方

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex) // 给Vue注入了一个 $state

export default new Vuex.Store({
    // 定义数据的地方
    state: {
        name: '朱昆鹏',
        age: 21
    }
    // ...
})
```

> 那么我们如何在 Vue 组件中展示状态呢？由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态（这句话划重点，虽然可以在其他地方也能获取的到，但是 在计算属性中设置 才有响应式的效果）

```html
<template>
    <div>
        {{ name }}
        {{ age }}
    </div>
</template>

<script>
import { mapState } from 'vuex'

export default {
    data () {
        return {
            age: 1998
        }
    },
    computed: {
        name () {
            return this.$store.state.name
        },
        age () {
            return this.$store.state.age
        }
    }
    // 当一个组件需要获取多个状态时候，我们可以使用 mapState 辅助函数帮助我们生成计算属性
    computed: {
        ...mapState(['name', 'age']) // 这么写你会发现最后显示的 age 是 1998，因为最后是走 data 中的
        // 🔥 使用传对象的方式，就能写别的名字了，这里访问 $store.state.newAge 就行
        // ...mapState({
        //     newAge: state => state.name
        // })
    }
}
</script>
```

---

### 3.getter（Vuex中的计算属性，先这么理解吧）

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex) // 给Vue注入了一个 $state

export default new Vuex.Store({
    // 定义数据的地方
    state: {
        name: '朱昆鹏',
        age: 21
    },
    getters: {
         nameAndAge (state) {
             return `姓名：${state.name} 年龄：${state.age}`
         }
    }
})
```

```html
<template>
    <div>
        {{ nameAndAge }}
        {{ nameAndAge1 }}
    </div>
</template>

<script>
import { mapGetters } from 'vuex'
export default {
    data () {
        return {
            nameAndAge: '名字冲突了，使用mapGetters 定义别名 解决'
        }
    },
    computed: {
        nameAndAge () {
            return this.$store.getters.nameAndAge
        }
    }
    // 当一个组件需要获取多个状态时候，我们可以使用 mapState 辅助函数帮助我们生成计算属性
    computed: {
        ...mapGetters(['nameAndAge'])
        // ...mapGetters({
        //     nameAndAge1 => getters => getters.nameAndAge
        // })
    }
}
</script>
```


---

### 4.mutations（store 中的状态的唯一方法）

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex) // 给Vue注入了一个 $state

export default new Vuex.Store({
    // 定义数据的地方
    state: {
        name: '朱昆鹏',
        age: 21
    },
    
    mutations: {
        changeName (state, name) {
            state.name = name
        }
        ageAdd (state, { num }) {
            ageAdd += num
        },
    }
})
```

```html
<template>
    <div><div>
</template>

<script>
import { mapMutations } from 'vuex'

export default {
    data () {
        return {
        }
    },
    methods: {
        ...mapMutations(['changeName', 'ageAdd']),
        changClick () {
            this.$store.commit('changeName', '其他名字')
            this.ageAdd({ num: 10 })
        }
    }
}
</script>
```

> 注意 mutations 里面的 内容 不会有延迟，按着顺序就执行完成了，里面写上异步代码也是没有用，怎么解决呢，用 active 来做异步的提交改变

---

### 5.action（内部可以写异步，然后异步触发mutations）

> 我们可以在action内部执行异步

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex) // 给Vue注入了一个 $state

export default new Vuex.Store({
    // 定义数据的地方
    state: {
        name: '朱昆鹏',
        age: 21
    },
    
    mutations: {
        changeName (state, name) {
            state.name = name
        }
    },

    actions: {
        // commit 是 全局上下文
        changeName ( { commit }, name ) {
            setTimeout( () => {
                commit('changeName', name)
            }, 1000)
        }
    }

})
```

```html
<template>
    <div>
        <button @click="changClick">1s后改变名字</button>
    </div>
</template>

<script>
import { mapActions } from 'vuex'

export default {
    data () {
        return {
        }
    },
    methods: {
        ...mapActions(['changeName']),

        changClick () {
            this.$store.commit('changeName', '其他名字') // 1s后 名称还是不变
            this.$store.dispath('changeName', '其他名字') // 1s后 名字变了

            // this.changeName('其他名字')
        }
    }
}
</script>
```

---

### 6.module（分模块）

> 一般都是建立一个文件夹（store），里面有 index.js 和 modules文件夹，我下面举例 zhukunpeng & girlfriend 两个模块

```js
import Vue from 'vue'
import Vuex from 'vuex'
import zhu from './modules/zhukunpeng.js'
import lin from './modules/girlfriend.js'

Vue.use(Vuex)

export default new Vuex.Store({
    modules: {
        zhu,
        lin
    }
})
```

```js
// store/modules/zhukunpeng.js
export default {
    state: {
        name: '朱昆鹏',
        age: 21
    },

    getters: {},

    mutations: {},

    actions: {}
}
```

```js
// store/modules/girlfriend.js
export default {
    state: {
        name: '朱昆鹏的女朋友',
        age: 21
    },

    getters: {},
    
    mutations: {},

    actions: {}
}
```

```html
<template>
    <div>
        姓名：{{ $store.state.zhu.name }}
        女朋友：{{ $store.state.lin.name }}
        <!-- 除了 state ，其他方式不变，也不用加别动东西，就跟写到 index.js 里面一样 -->
    </div>
</template>
```

> 注意：这种分层之后，可以通过 mapXXX 方式 拿到 getters mutations action，但是不能拿到 state，如果想通过 mapXXX 的方式获取 state，需要给每个模块 加上命名空间 namespaced: true

- 但是这样的话，获取方式就会发生改变 例如 ： $store.getters.xxx ===>  $store['命名空间名称/getters'].xxx || ...mapGetters(['xxx']) ===> ...mapGetters('命名空间名称',['xxx'])
- ❣️ 推荐是使用命名空间

---

## 🎾第五部分：Vue测试（Jest）

---

## 🎱第六部分：Vue测试（mocha）

---

## ⛳️第七部分：UI组件库（Element）