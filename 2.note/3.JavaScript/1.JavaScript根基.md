# 1.JavaScript根基

## 🐲第零章：JavaScript简介

### 1.web发展史 和 JS 历史

Mosaic, 是互联网历史上第一个普遍使用和能够显示图片的网页浏览器。于1993年问世

<img src ="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/1.png" />


### 2.浏览器的组成

- shell部分（能看到的，浏览上边，设置，历史记录，下载记录这些用户能够操作的）
- 内核部分（看不到的，但是能让浏览器运行起来的部分）
  - 渲染引擎（语法规则和渲染）
  - JS引擎
  - 其他模块（负责异步等）

### 3.JS的特色（我有你没有的东西）

- 解释性语言（不需要编译 - 可以跨平台）
- 单线程
- ......

---

## 🌵第一章：基础语法

### 1.和C语言类似的地方（主要是语法）

```js

// 变量定义（关键字 变量名 = 变量值）
var a = 10

// 函数定义
function fn () {

}

// 条件判断
if (true) {

} else {

}

// for循环
for (let i = 0; i < 10; i++) {

}

// switch
switch (num) {
    case 1: '';break;
    case 2: '';break;
    case 3: '';break;
}

```


### 2.数据类型（包括类型转换）

- String
- Number
- Boolean
- Array
- Object（Function，Math, ...）
- Map（ES6）
- Set（ES6）

---

### 4.关键字

- var
- function
- 
- let
- const
- class

---

### 3.常用方法

window上的

---

## 🎄第二章：基础概念过度

### 1.类型转换

**很多语言中都有类型转换，例如 '123' 这是字符串类型，我们可以通过类型转换变为 123，这种类型转换是最常用的，JavaScript中的类型转换坑还是比较多的，所以我要整理一下这里，做到了解，并尽量避免发生隐式类型转换**

---

**显示类型转换**

```js

// 显示类型转换的方法

Number() // 转为数值类型
parseInt() // 转为整数
parseFloat() // 转为浮点数
Boolean() // 转为布尔类型 
String() // 转为字符串
xxx.toString() // 转为字符串（undefind 和 null 不能转，会报错，因为这两个上面没有toString()）

```

---

**隐式类型转换**

```js

// ❣️ 数字优先原则，如果有数字能触发隐式的话，先触发数字转换

// isNaN() 传入其中的参数先调用Number()进行转换，再和NaN进行比较
isNaN(1) // false
isNaN(true) // fasle
isNaN(NaN) // ture
isNaN('zhu') // ture| Number('zhu') // NaN

// 加加 减减 正号 负号 隐式调用Number()
++ -- + -

// 加号 会隐式调用 toString，例如 'zhu' + 1 ==> 'zhu1'
+

// 隐式调用 Number()
- * / %

// 会触发类型转换，具体调用哪个转换方法，根据情况来
&& || !

// 会触发类型转换，具体调用哪个转换方法，根据情况来
// < > <= >=

// 会触发类型转换，具体调用哪个转换方法，根据情况来
== !=

// 特殊的
undefined == null // true
NaN === NaN // false 谁都不等
=== !== // 不发生类型转换

```

---



## 🌴第三章：数值（Number）

---

## 🌱第四章：字符（String）

---

## 🍃第五章：布尔（Boolean）

---

## 🌿第六章：数组（Array）

---


## 🌲第七章：函数（Function）

### 1.函数基础

```js

// ****** 🔥定义函数（有两种，函数声明 和 函数表达式）******

// 函数声明
function fn1 () {

}

// 函数表达式
let fn2 = function () {

}
// 1. function () {} 这种叫做匿名表达式
// 2. (function () {})()  这个是IIEF立即执行函数（立即执行函数还有好几种）
// 3. 函数调用我就不写了...



// ****** 🔥函数的参数 ******

// 函数的参数，可以传递任何类型，包括一个函数，并且实参或者形参都不限制位数
// 什么形参，实参，我就不想解释了
// arguments 是js函数的 实参列表（类数组），我也不解释了


// ****** 🔥函数的返回值 ******

// 1.如何函数里面没写 return 那么会默认返回 undefined

```

---

### 2.函数的属性和方法

**属性**

- name: 函数名
- arguments: 实参列表
- length: 
- caller: 

**方法**

- apply(): 改变this指向
- bind(): 改变this指向
- call(): 改变this指向
- toString(): 将函数转为字符串（是真的转为字符串了）

---

### 3.递归

---

### 4.call/apply（改变this指向）

- call 需要把实参按照形参的个数穿进去
- apply 只能传一个值，那个值必须是数组（有就是实参列表，arguments）
- 他们两个都只有一个功能，就是 改变 this 的指向，然后根据这个现象 可以导出一个功能，那就是  借助别人的方法来实现自己的功能

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/3.png" />



---

## 🍀第八章：对象（Object）

**对象是引用类型**

### 1.对象的基本使用

```js

// 对象定义（对象字面量 推荐）
let me = {

    name: '朱昆鹏',
    age: 20,

    // 方法
    say: function () {
        console.log(me.age) // 20
        console.log(this.age) // 20，this 其实就是 AO 里面的一个属性，具体可以看3.JavaScript深入
    },

    // 方法的另一种写法（ES6）
    look () {}

}


// 对象属性的增删改查
me.test = '测试属性' // 增
delete me.test // 删 | 后期可以知道 一个对象的对象，能不能被删除其实都可以控制的（Object.defineProperties)
me.age = 21 // 改
me.age // 21 查


// 其他定义对象的方式

// 1.构造函数创建对象（需要new）
let obj1 = new Object() // 系统自带的构造函数 Object()
let obj2 = new Zhu() // 自己写的一个构造函数

// 2.
let obj = Object.create(null)

```

---

### 2.构造函数示例

**这里面就涉及到this，具体请看3.JavaScript深入 this解释**

```js

function Car (carName) {

    // 属性
    this.name = carName || 'BMW'
    
    // 方法
    this.run = function () {
        console.log(this.name + '跑了起来')
    }
}

let byd = new Car('byd')
let dz = new Car('dz')

byd.run() // byd跑了起来
dz.run() // dz跑了起来

```

---

### 3.new 操作符做了什么（构造函数内部原理）

- 第一步：在函数体最前面隐式的加上 this = {}
- 第二步：执行 this.xxx = xxx
- 第三步：隐式的返回this

**我们根据这三步，来写一个显示的函数，不用new，看看是否能达到上面的效果**

```js

function Car (carName) {

    let that = {} // this 是关键字，不行，所以，我们用 that 代替，效果是一样的

    // 属性
    that.name = carName || 'BMW'
    
    // 方法
    that.run = function () {
        console.log(that.name + '跑了起来')
    }

    return that
}

let byd = Car('byd')
let dz = Car('dz')

byd.run() // byd跑了起来
dz.run() // dz跑了起来

```

---

**❣️❣️❣️ 因为new 最后隐式的返回了对象，这个对象中如果有 函数的话，就会形成闭包，也就是这个函数具有 构造函数的作用域**

```js

function Zhu () {
    
    this.age = 20,

    this.addAge =  function () {
        this.age += 1
    }

}

let zhu1 = new Zhu() // 产生 Zhu 的 AO 和 addAge的 AO 
let zhu2 = new Zhu() // 产生 Zhu 的 AO 和 addAge 的 AO ，注意 这里面的

zhu1.addAge() // 这里的 addAge 里面有三个作用域：0 addAge的AO，1 Zhu的AO，和GO
zhu1.age // 21

zhu2.addAge() // 这里的 addAge 里面有三个作用域：0 addAge的AO，1 Zhu的AO，和GO，但是其中的 Zhu的AO 和 上面的不一样，虽然内容一样，但是相互独立的
zhu2.age // 21

// ❓ 在运用我发现，Zhu 和 zhu1.addAge 都只有两个作用域 Script 和 Global 这是为什么

```

**❣️如果使用了new关键字的话，因为有隐式返回，所以就算在函数中写返回，还是会被忽略**

---

### 4.原型，原型链

**首先要明确：函数也是对象，是对象都有 __proto__ 和 constructor，函数有特定的属性 prototype**

- 原型（prototype）：是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先
    - 通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是一个对象，利用原型的特点和概念，可以提取公共属性
    - 对象查看原型 __ proto __
    - 拓展：对象如何查看 对象的构造函数 --> constructor
- 原型链：

```js

function Zhu () { }
Zhu.prototype.say = function () {
    console.log('我会说话')
}

let zhu1 = new Zhu()
let zhu2 = new Zhu()

```

**啥都不说，补一张图，什么都明白了（有空话一张）**
 

---

### 5.继承实现

- 继承需要满足两个，一个是继承属性，一个是继承方法
    - 继承属性：父.call(this, ...)
    - 继承方法：将父的prototype给 子类，并且让 子类的 constructor 保持正常（一般是写一个方法做这个事情）

```js
// 最佳实践
function Father (name) {
    this.name = name
}
Father.prototype.say = funciton () { }

// 如何让 Son 继承 Father
function Son (name) {
    Father.call(this, name) // 继承属性
}

inheritPropertype(Father, Son)

// 继承方法的函数（可能还有其他的版本，但是大致意思是 将父的prototype给 子类，并且让 子类的 constructor保持正常）
funciton inheritPropertype(father, son) {
    let protoType = Object.create(father.prototype)
    prototype.constructor = son
    son.prototype = protoType
}

```

**❣️ ES6 有了 Class之后，继承方便了很多，所以上面那种方式，一般感觉只有面试可以用到**

---

### 6.包装类

我们知道在JavaScript中有原始值和引用值，原始值是没有属性和方法的，但是包装类产生的原始值是有的

- new String()
- new Boolean()
- new Number()

```js

let num1 = 100;
num1 // 100 是没有属性和方法的

let num2 = new Number(100)
num2 // Number {100} 是有属性和方法的
num2 + 1 // 101 可以参与运算，运算之后就变为了原始值

// 解释一个匪夷所思的问题
num1.length = 1
console.log(num1.length) // undefined，为什么不报错？，因为先隐式的调用了 包装类



// ******* 试题一 *******
let str = 'zhu'
str = str + 1
let test = typeof str // 'string'
if (test.length == 6) { // test.length // undefined
    test.sign = '返回'
}
console.log(test.sign) // undefined
```

---

### 7.命名空间,对象枚举

**对象枚举（又叫对象属性遍历）**

- 我们的数组很好遍历，for 循环就可以搞定，但是 你的对象怎么遍历呢 ？
- for in 循环 ：实现对象的遍历

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/5.png" />

**但是这个有个问题，就是通过 for in 遍历对象，也可以把对象的原型链上的属性遍历出来，怎么办呢？  ----->  hasOwnProperty() 参数传入字符串类型的属性名，返回布尔值，表示是否是自己的属性**

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/6.png" />

**拓展 ：in 操作符 ：判断你是否可以访问到某个属性（和 hasOwnProperty() 的功能不同哦）（基本用不到，了解就可以）**

- 重点拓展 ：instanceof 
  - a instanceof A   // 判断 a对象 是否是 A构造函数构造出来的 （当然这个用法没有想象的那么简单）（ a instanceof Object 也会返回 true）
  - 其实根本的理解应该是 ：判断a对象的原型链上 有没有 A的原型
- 这个instanceof解决了一个很重要的问题，就是之前，typeof [ ]   typeof { }  返回的都是 object 没办法区分
  - 第一种方法 ：constraint
  - 第二种方法 ：instanceof
  - 第三种方法 ：Object.prototype.toString.call(里面写需要判断的)


---

## 🎋第九章：其他（基本类型）

---

## 🌻第十章：DOM

### 1.DOM基本解释

**什么是DOM**

DOM（document object model） 文档对象模型，定义了表示和修改文档的方法，DOM对象既为宿主对象，由浏览器厂商定义，用来操作HTML和XML功能的一类对象的集合（web标准编程接口）

DOM结构树（先用网上的图，后期自己画一下）

<img src="https://upload-images.jianshu.io/upload_images/10312944-e129b1a7aaf0a987.png" />

---

### 2.常用DOM接口

```js

// 获取DOM节点
document.getElementById() // 通过ID获取
document.getElementsByTagName() // 标签名
document.getElementsByClassName() // 类名
document.querySelector() // 通过选择器获取一个元素
document.querySelectorAll() // 通过选择器获取一组元素
document.body // 获取body的方法
document.getElementsByName(name) // 通过name属性查找元素节点
document.documentElement // 获取html的方法

// 节点类型
元素节点（标签） // 属性nodeType返回值1
属性节点（标签里的属性）// 返回值2
文本节点 // 返回值3
注释节点（comment） // 返回值8
document // 返回值9
DocumentFragment // 返回值11

// 节点接口
dom元素.parentNode // 返回当前元素的父节点
dom元素.childNodes // 子节点们
dom元素.firstChild // 第一个子节点
dom元素.lastChild // 最后一个子节点
dom元素.nextSibling // 后一个兄弟节点 previousSibling -> 前一个兄弟节点

// 元素节点接口
dom元素.parentElement // 返回当前元素的父元素节点
dom元素.children // 返回当前元素的元素子节点
dom元素.firstElementChild // 第一个元素子节点（IE不兼容）
dom元素.lastElementChild // 最后一个元素子节点（IE不兼容）
dom元素.nextElementSibling // 返回后一个兄弟元素节点
dom元素.previousElementSibling // 返回前一个兄弟元素节点

// 节点的四个属性和一个方法
节点.nodeName // 元素的标签名，以大写形式表示（只读）
节点.nodeValue // Text节点或者Comment节点的文本内容，（读写）
节点.nodeType // 该节点的类型（只读）
节点.attributes // Element节点的属性集合
节点.hasChildNodes() // 判断节点 是否有子节点

// Element节点的 属性和方法
dom元素.innerHtml
dom元素.innerText
dom元素.attributes // 获取元素身上所有属性构成的集合
dom元素.setAttribute("属性名","属性值")// 给元素设置属性和属性值
dom元素.getAttribute("属性名")// 获取属性值的方法
dom元素.removerAttribute("属性") // 删除属性


// ============== 操作接口 ==================

// 增
document.createElement() // 创建元素节点
document.createTextNode() // 创建文本节点
document.creaetComment() //创建注释节点
document.createDocumentFragment() // 创建文档碎片节点

// 插
父元素节点.appendChild(子元素对象) // 在元素节点的子元素最后插入子元素
父元素节点.insertBefore(父元素中的子元素a, 需要插入的子元素b) // 最后的结果是，父元素节点中 b元素插入到了 a的前面


// 删
元素节点.remove() // 删除DOM元素（自己）
父元素节点.removeChild(子元素节点) // 删除子元素

// 替换
父元素节点.replaceChild(新的节点, 需要被替换的子节点)

// 复制
元素节点.cloneChild() // 返回值是 复制出来的节点

// 元素节点赋值 示例
dom元素.style.width = ...
dom元素.style.backgroundColor = ...
dom元素.className = ...

```

---

### 3.DOM继承树

<img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1567450094844&di=b6a47996f4baad433acfd0ec74d4d2eb&imgtype=0&src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2Fdcef2cf7735f46627c7d9dfec51d1caa.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100" />

**有那么几点需要注意❣️**

- getElementById 方法定义在 Document.prototype 上（Element节点不能使用）（感觉这点面试的时候可以问，可以问出来面试者的DOM节点基础）
- getElementsByName 方法定义在HTMLDocument.prototype上（非document节点不能使用）
- getElementsByTagName 方法定义在 Document.prototype 和 Element.prototype
- HTMLDocument.prototype定义了一些常用属性，body, head分别指代HTML文档中的 body 和 head 标签
- Document.prototype 上定义了documentElement属性，指代元素的根元素，在HTML文档中，他总是指代 html 元素
- getElementsByClassName,querySelectAll,querySelector在 Document.prototype, Element.prototype类中均有定义

---

### 4.试题

**遍历某元素节点树（在原型链上编程）**

```js

```

**封装函数，返回某元素的第n层祖先元素节点**

```html
<body>
    <div>
        <strong>
            <span>
                <i></i>
            </span>
        </strong>
    </div>
</body>

<script type="text/javascript">

function retParent(ele, n) {
    
    while(elem && n) {
        ele = ele.parentElement
        n--
    }

    return ele
}

</srcipt>
```


**编辑函数，封装myChildren功能，解决以前部分浏览器兼容性问题**

```js
Element.prototype.myChildren = function () {
    
    let child = this.childNodes,
        len = child.length,
        arr = []
    
    for (let i = 0; i < len; i++) {
        child[i].nodeType === 1 ? arr.push(child[i]) : ''
    }

    return arr
}
```

**自己封装hasChildren()方法，不可用children属性**

```js
Element.prototype.myHasChildren = function () {
    
    let child = this.childNodes,
        len = child.length,
        arr = []
    
    for (let i = 0; i < len; i++) {
        if (child[i].nodeType === 1) {
            return true
        } else {
            return false
        }
    }
}
```

**封装函数，返回元素e的第n个兄弟元素节点，n为正，返回后面的兄弟元素节点，n为负，返回前面的，n为0，返回自己**

```js

function retSibling(e, n) {
    
    whild(e && n) {

        if (n > 0) {
            if (e.nextElementSibling) {
                e = e.nextElementSibling
            } else {
                for (e = e.nextSibling; e.nodeType != 1; e = e.nextSibling)
            }

            n--
        } else {
            e = e.previousElementSibling
            n++
        }

        return e
    }
}

```

**封装函数insertAfter()，功能类似 insertBefore()，当然我可以封装一个更强大的**

```js
```

---

## 🌾第十一章：BOM

### 1.BOM基础介绍

---

### 2.BOM常用接口

---

## 🍄第十二章：其他（DOM，BOM）

---

## ❤️参考列表（致敬）

- 《JavaScript高级程序编程》 && 《JavaScript权威指南》
- [腾讯课堂 渡一教育公开课](https://ke.qq.com/course/231577?taid=2841395744442521)
- 《你不知道的JavaScript》上中下