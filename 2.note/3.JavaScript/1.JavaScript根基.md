# 1.JavaScript根基

## 🐲第零章：JavaScript简介

### 1.web发展史 和 JS 历史

Mosaic, 是互联网历史上第一个普遍使用和能够显示图片的网页浏览器。于1993年问世

<img src ="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/1.png" />


### 2.浏览器的组成

- shell部分（能看到的，浏览上边，设置，历史记录，下载记录这些用户能够操作的）
- 内核部分（看不到的，但是能让浏览器运行起来的部分）
  - 渲染引擎（语法规则和渲染）
  - JS引擎
  - 其他模块（负责异步等）

### 3.JS的特色（我有你没有的东西）

- 解释性语言（不需要编译 - 可以跨平台）
- 单线程
- ......

---

## 🌵第一章：基础语法

### 1.和C语言类似的地方（主要是语法）

```js

// 变量定义（关键字 变量名 = 变量值）
var a = 10

// 函数定义
function fn () {

}

// 条件判断
if (true) {

} else {

}

// for循环
for (let i = 0; i < 10; i++) {

}

// switch
switch (num) {
    case 1: '';break;
    case 2: '';break;
    case 3: '';break;
}

```


### 2.数据类型（包括类型转换）

- String
- Number
- Boolean
- Array
- Object（Function，Math, ...）
- Map（ES6）
- Set（ES6）

---

### 4.关键字

- var
- function
- 
- let
- const
- class

---

### 3.常用方法

window上的

---

## 🎄第二章：基础概念过度

### 1.类型转换

**很多语言中都有类型转换，例如 '123' 这是字符串类型，我们可以通过类型转换变为 123，这种类型转换是最常用的，JavaScript中的类型转换坑还是比较多的，所以我要整理一下这里，做到了解，并尽量避免发生隐式类型转换**

---

**显示类型转换**

```js

// 显示类型转换的方法

Number() // 转为数值类型
parseInt() // 转为整数
parseFloat() // 转为浮点数
Boolean() // 转为布尔类型 
String() // 转为字符串
xxx.toString() // 转为字符串（undefind 和 null 不能转，会报错，因为这两个上面没有toString()）

```

---

**隐式类型转换**

```js

// ❣️ 数字优先原则，如果有数字能触发隐式的话，先触发数字转换

// isNaN() 传入其中的参数先调用Number()进行转换，再和NaN进行比较
isNaN(1) // false
isNaN(true) // fasle
isNaN(NaN) // ture
isNaN('zhu') // ture| Number('zhu') // NaN

// 加加 减减 正号 负号 隐式调用Number()
++ -- + -

// 加号 会隐式调用 toString，例如 'zhu' + 1 ==> 'zhu1'
+

// 隐式调用 Number()
- * / %

// 会触发类型转换，具体调用哪个转换方法，根据情况来
&& || !

// 会触发类型转换，具体调用哪个转换方法，根据情况来
// < > <= >=

// 会触发类型转换，具体调用哪个转换方法，根据情况来
== !=

// 特殊的
undefined == null // true
NaN === NaN // false 谁都不等
=== !== // 不发生类型转换

```

---



## 🌴第三章：数值（Number）

---

## 🌱第四章：字符（String）

---

## 🍃第五章：布尔（Boolean）

---

## 🌿第六章：数组（Array）

---


## 🌲第七章：函数（Function）

### 1.函数基础

```js

// ****** 🔥定义函数（有两种，函数声明 和 函数表达式）******

// 函数声明
function fn1 () {

}

// 函数表达式
let fn2 = function () {

}
// 1. function () {} 这种叫做匿名表达式
// 2. (function () {})()  这个是IIEF立即执行函数（立即执行函数还有好几种）
// 3. 函数调用我就不写了...



// ****** 🔥函数的参数 ******

// 函数的参数，可以传递任何类型，包括一个函数，并且实参或者形参都不限制位数
// 什么形参，实参，我就不想解释了
// arguments 是js函数的 实参列表（类数组），我也不解释了


// ****** 🔥函数的返回值 ******

// 1.如何函数里面没写 return 那么会默认返回 undefined

```

---

### 2.函数的属性和方法

**属性**

- name: 函数名
- arguments: 实参列表
- length: 
- caller: 

**方法**

- apply(): 改变this指向
- bind(): 改变this指向
- call(): 改变this指向
- toString(): 将函数转为字符串（是真的转为字符串了）

---

### 3.递归

---

### 4.call/apply（改变this指向）

- call 需要把实参按照形参的个数穿进去
- apply 只能传一个值，那个值必须是数组（有就是实参列表，arguments）
- 他们两个都只有一个功能，就是 改变 this 的指向，然后根据这个现象 可以导出一个功能，那就是  借助别人的方法来实现自己的功能

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/3.png" />



---

## 🍀第八章：对象（Object）

**对象是引用类型**

### 1.对象的基本使用

```js

// 对象定义（对象字面量 推荐）
let me = {

    name: '朱昆鹏',
    age: 20,

    // 方法
    say: function () {
        console.log(me.age) // 20
        console.log(this.age) // 20，this 其实就是 AO 里面的一个属性，具体可以看3.JavaScript深入
    },

    // 方法的另一种写法（ES6）
    look () {}

}


// 对象属性的增删改查
me.test = '测试属性' // 增
delete me.test // 删 | 后期可以知道 一个对象的对象，能不能被删除其实都可以控制的（Object.defineProperties)
me.age = 21 // 改
me.age // 21 查


// 其他定义对象的方式

// 1.构造函数创建对象（需要new）
let obj1 = new Object() // 系统自带的构造函数 Object()
let obj2 = new Zhu() // 自己写的一个构造函数

// 2.
let obj = Object.create(null)

```

---

### 2.构造函数示例

**这里面就涉及到this，具体请看3.JavaScript深入 this解释**

```js

function Car (carName) {

    // 属性
    this.name = carName || 'BMW'
    
    // 方法
    this.run = function () {
        console.log(this.name + '跑了起来')
    }
}

let byd = new Car('byd')
let dz = new Car('dz')

byd.run() // byd跑了起来
dz.run() // dz跑了起来

```

---

### 3.new 操作符做了什么（构造函数内部原理）

- 第一步：在函数体最前面隐式的加上 this = {}
- 第二步：执行 this.xxx = xxx
- 第三步：隐式的返回this

**我们根据这三步，来写一个显示的函数，不用new，看看是否能达到上面的效果**

```js

function Car (carName) {

    let that = {} // this 是关键字，不行，所以，我们用 that 代替，效果是一样的

    // 属性
    that.name = carName || 'BMW'
    
    // 方法
    that.run = function () {
        console.log(that.name + '跑了起来')
    }

    return that
}

let byd = Car('byd')
let dz = Car('dz')

byd.run() // byd跑了起来
dz.run() // dz跑了起来

```

---

**❣️❣️❣️ 因为new 最后隐式的返回了对象，这个对象中如果有 函数的话，就会形成闭包，也就是这个函数具有 构造函数的作用域**

```js

function Zhu () {
    
    this.age = 20,

    this.addAge =  function () {
        this.age += 1
    }

}

let zhu1 = new Zhu() // 产生 Zhu 的 AO 和 addAge的 AO 
let zhu2 = new Zhu() // 产生 Zhu 的 AO 和 addAge 的 AO ，注意 这里面的

zhu1.addAge() // 这里的 addAge 里面有三个作用域：0 addAge的AO，1 Zhu的AO，和GO
zhu1.age // 21

zhu2.addAge() // 这里的 addAge 里面有三个作用域：0 addAge的AO，1 Zhu的AO，和GO，但是其中的 Zhu的AO 和 上面的不一样，虽然内容一样，但是相互独立的
zhu2.age // 21

// ❓ 在运用我发现，Zhu 和 zhu1.addAge 都只有两个作用域 Script 和 Global 这是为什么

```

**❣️如果使用了new关键字的话，因为有隐式返回，所以就算在函数中写返回，还是会被忽略**

---

### 4.原型，原型链

**首先要明确：函数也是对象，是对象都有 __proto__ 和 constructor，函数有特定的属性 prototype**

- 原型（prototype）：是function对象的一个属性，它定义了构造函数制造出来的对象的公共祖先
    - 通过该构造函数产生的对象，可以继承该原型的属性和方法，原型也是一个对象，利用原型的特点和概念，可以提取公共属性
    - 对象查看原型 __ proto __
    - 拓展：对象如何查看 对象的构造函数 --> constructor
- 原型链：

```js

function Zhu () { }
Zhu.prototype.say = function () {
    console.log('我会说话')
}

let zhu1 = new Zhu()
let zhu2 = new Zhu()

```

**啥都不说，补一张图，什么都明白了（有空话一张）**
 

---

### 5.继承实现

- 继承需要满足两个，一个是继承属性，一个是继承方法
    - 继承属性：父.call(this, ...)
    - 继承方法：将父的prototype给 子类，并且让 子类的 constructor 保持正常（一般是写一个方法做这个事情）

```js
// 最佳实践
function Father (name) {
    this.name = name
}
Father.prototype.say = funciton () { }

// 如何让 Son 继承 Father
function Son (name) {
    Father.call(this, name) // 继承属性
}

inheritPropertype(Father, Son)

// 继承方法的函数（可能还有其他的版本，但是大致意思是 将父的prototype给 子类，并且让 子类的 constructor保持正常）
funciton inheritPropertype(father, son) {
    let protoType = Object.create(father.prototype)
    prototype.constructor = son
    son.prototype = protoType
}

```

**❣️ ES6 有了 Class之后，继承方便了很多，所以上面那种方式，一般感觉只有面试可以用到**

---

### 6.包装类

我们知道在JavaScript中有原始值和引用值，原始值是没有属性和方法的，但是包装类产生的原始值是有的

- new String()
- new Boolean()
- new Number()

```js

let num1 = 100;
num1 // 100 是没有属性和方法的

let num2 = new Number(100)
num2 // Number {100} 是有属性和方法的
num2 + 1 // 101 可以参与运算，运算之后就变为了原始值

// 解释一个匪夷所思的问题
num1.length = 1
console.log(num1.length) // undefined，为什么不报错？，因为先隐式的调用了 包装类



// ******* 试题一 *******
let str = 'zhu'
str = str + 1
let test = typeof str // 'string'
if (test.length == 6) { // test.length // undefined
    test.sign = '返回'
}
console.log(test.sign) // undefined
```

---

### 7.命名空间,对象枚举

**对象枚举（又叫对象属性遍历）**

- 我们的数组很好遍历，for 循环就可以搞定，但是 你的对象怎么遍历呢 ？
- for in 循环 ：实现对象的遍历

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/5.png" />

**但是这个有个问题，就是通过 for in 遍历对象，也可以把对象的原型链上的属性遍历出来，怎么办呢？  ----->  hasOwnProperty() 参数传入字符串类型的属性名，返回布尔值，表示是否是自己的属性**

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.note/4.%E6%8A%80%E6%9C%AF%E6%A0%B9%E5%9F%BA%E7%AC%94%E8%AE%B0/JS%E6%A0%B9%E5%9F%BA/6.png" />

**拓展 ：in 操作符 ：判断你是否可以访问到某个属性（和 hasOwnProperty() 的功能不同哦）（基本用不到，了解就可以）**

- 重点拓展 ：instanceof 
  - a instanceof A   // 判断 a对象 是否是 A构造函数构造出来的 （当然这个用法没有想象的那么简单）（ a instanceof Object 也会返回 true）
  - 其实根本的理解应该是 ：判断a对象的原型链上 有没有 A的原型
- 这个instanceof解决了一个很重要的问题，就是之前，typeof [ ]   typeof { }  返回的都是 object 没办法区分
  - 第一种方法 ：constraint
  - 第二种方法 ：instanceof
  - 第三种方法 ：Object.prototype.toString.call(里面写需要判断的)


---

## 🎋第九章：其他（基本类型）

---

## 🌻第十章：DOM

---

## 🌾第十一章：BOM

---

## 🍄第十二章：其他（DOM，BOM）
