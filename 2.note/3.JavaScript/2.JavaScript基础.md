# 2.JavaScript基础

**对应《JavaScript高级程序编程》**

---

## 🌲数组（Array）

---

### 🔥基本使用

- forEach(): 遍历数组
- pop()：删除数组中最后一个元素，并返回该元素的值。此方法更改数组的长度
- shift()：删除数组中第一个元素，并返回该元素的值。此方法更改数组的长度
- push(): 将一个或多个元素添加到数组的末尾，并返回该数组的新长度
- unshift()：将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)

---

### 🔥处理：Array.prototype.map()

**map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果**

- 此方法可以批量处理 数组中的每一个元素，并且返回值（不会改变原数组）

```js
[1, 2, 3].map( x => x * 2) // [2, 4, 6]
```

---

### 🔥处理：Array.prototype.join()

**join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。**

```js
['Fire', 'Air', 'Water'].join() // "Fire,Air,Water"
['Fire', 'Air', 'Water'].join('') // "FireAirWater"
['Fire', 'Air', 'Water'].join('-') // "Fire-Air-Water"
```

---

### 🔥处理：Array.prototype.slice() 取出任意元素

**slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。**

- 拿到数组中任意区间的数据

```JS
// 参数一：从哪开始，参数二（可选）结束位置，不选的话 就节选到最后了
[1, 2, 3].slice(0, 1) // [1]
[1, 2, 3].slice(0, 0) // []
```

---

### 🔥处理：Array.prototype.splice() 删除任意元素，操作任意元素

**splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。**

```js
// 参数一：从哪开始 | 参数二：操作元素的个数 | 参数三：插入元素的值...（可以写多个参数三）
[1, 2, 3].splice(0, 1) // 删除 [2, 3]
[1, 2, 3].splice(0) // 删除 [0]
[1, 2, 3].splice(0, 0, -1) // 插入 [-1, 1, 2, 3]
```

---

### 排序：Array.prototype.sort()

**sort() 方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点**

```js
[1, 1000, 1002, 200, 40].sort() // [1, 1000, 1002, 200, 40] 因为是根据 字符串Unicode码点进行排序的
[1, 1000, 1002, 200, 40].sort( (a, b) => a - b) // 升序 [1, 40, 200, 1000, 1002]
[1, 1000, 1002, 200, 40].sort( (a, b) => b - a) // 降序 [1002, 1000, 200, 40, 1]
```

---

### 🔥处理：Array.prototype.flatMap()

**flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。不会改变原数组**

- 感觉这个像是操作每一个对象，让其可以返回一个值，我觉得可以应用到 将每一项的 字符串转为特定的，我之前使用 forEach 做的
- 首先经历了两步：
    - flat() 将多维数组转为一个新数组
    - map() 

```js

[1, 2, 3].flatMap( x => x * 2) // [2, 4, 6]
[1, 2, 3].map( x => x * 2) // [2, 4, 6]

// 虽然上面用 map 和 flatMap都可以，但是下面
["今天天气不错", "", "早上好"].map(s => s.split('')) // [["今", "天", "天", "气", "不", "错"],[""],["早", "上", "好"]]
["今天天气不错", "", "早上好"].flatMap(s => s.split('')) // ["今", "天", "天", "气", "不", "错", "", "早", "上", "好"]

```

---

### 🔥查询：Array.prototype.includes()

**includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。**

```js
[1, 2, 3].includes(1) // true
[1, 2, 3].includes(4) // false
[1, 2, 3].includes(1, 1) // false // 参数二：fromIndex 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。
```

---

### 🔥Array.prototype.reduce()

**reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。**

感觉很有用，但是我用的不熟练 [各种应用](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)

```js
[1, 2, 3, 4].reduce( (x, y) => x + y ) // 10 做累加
[1, 2, 3, 4, 1, 1].reduce( (allNames, name) => { 
  (name in allNames) ? allNames[name]++ : allNames[name] = 1;
  return allNames;
}, {}) // 计算数组中每个元素出现的次数 { 1: 3, 2: 1, 3: 1, 4: 1 }
```

---

### 排序：Array.prototype.reverse()

**reverse() 方法将数组中元素的位置颠倒,并返回该数组。该方法会改变原数组。**

---

### 查找：Array.prototype.indexOf()

**indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。**

```js
[1, 2, 3].indexOf(1) // 0
// 参数二：fromIndex 开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找 ，以此类推。 注意：如果参数中提供的索引值是一个负值，并不改变其查找顺序，查找顺序仍然是从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0.
[2, 5, 9].indexOf(2, -3) // 0
```

---

### 查询：Array.prototype.find() && Array.prototype.findIndex()

**find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。**

```js
let arr = [1, 2, 3]
arr.find(x => x > 1) // 2
arr.find(x => x >= 1) // 1
```

**findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1**

```js
let arr = [1, 2, 3]
arr.findIndex(x => x > 1) // 1
arr.findIndex(x => x >= 10) // -1
```

---

### 查询增加：Array.prototype.filter()

**filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素，不会改变原有值，如果没符合的返回[]**

```js
let arr = [1, 2, 3]
arr.filter( x => x > 1) // [2, 3]
```

---

### 查询测试：Array.prototype.every()

**every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。**

```js

let arr = [1, 2, 3]
arr.every( x => x > 2) // false

```

---

### 查询测试：Array.prototype.some()

**some() 方法测试是否至少有一个元素可以通过被提供的函数方法。该方法返回一个Boolean类型的值。**

```js

let arr = [1, 2, 3]
arr.some( x => x > 2) // true


```

---

### 增加：Array.prototype.concat()

**此方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。**

```js
let arr1 = [1, 2, 3],
    arr2 = [4, 5, 6],
    arr3 = [7, 8, 9]

let arr = arr1.concat(arr1, arr2) // [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

### Array.prototype.flat() 适合多维数组转一纬数组

**flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回**

```js
[1, 2, [3, 4]].flat() // [1, 2, 3, 4]
[1, 2, [3, 4, [5, 6]]].flat(1) // [1, 2, 3, 4, [5, 6]]
[1, 2, [3, 4, [5, 6]]].flat(Infinity) // [1, 2, 3, 4, 5, 6]
```

---

### 增加：Array.prototype.fill()

**fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。**

```js
// 有三个参数，| 用来填充数组元素的值 | 起始索引，默认值为0 | 终止索引，默认值为 this.length
[1, 2, 3].fill(4) // [4, 4, 4]
[1, 2, 3].fill(4, 1) // [1, 4, 4]
[1, 2, 3].fill(4, 1, 1) // [1, 2, 3]
```

---

### Array.prototype.toSting()

**toString() 返回一个字符串，表示指定的数组及其元素**

```js
[1, 2, 'a', '1a'].toString() // "1,2,a,1a"
```

---

### Array.prototype.lastIndexOf()

**lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。**

```js

['Dodo', 'Tiger', 'Penguin', 'Dodo'].lastIndexOf('Dodo') // 3

```

---

### Array.of()

**Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型**

我觉的这个我不常用，是用来创建数组的，与Array() 创建数组不同的是，这个是可变数量参数

```js
Array.of(7);       // [7] 
Array.of(1, 2, 3); // [1, 2, 3]

Array(7);          // [ , , , , , , ]
Array(1, 2, 3);    // [1, 2, 3]
```

---

### Array.prototype.copyWithin()

**copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。**

---

### Array.prototype.entries()

**entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对**

---

### Array.prototype.keys()

**keys() 方法返回一个包含数组中每个索引键的Array Iterator对象。**

```js
var array1 = ['a', 'b', 'c'];
var iterator = array1.keys(); 
  
for (let key of iterator) {
  console.log(key); // expected output: 0 1 2
}
```

---

### Array.prototype.values()

**values() 方法返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值**

```js
const array1 = ['a', 'b', 'c'];
const iterator = array1.values();

for (const value of iterator) {
  console.log(value); // expected output: "a" "b" "c"
}
```

---

### Array.prototype.reduceRight()

**reduceRight() 方法接受一个函数作为累加器（accumulator）和数组的每个值（从右到左）将其减少为单个值。**

---

### Array.prototype.toLocaleString()

**toLocaleString() 返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 ","）隔开。**

感觉有使用的场景

```js
['￥7', 500, 8123, 12].toLocaleString('ja-JP', { style: 'currency', currency: 'JPY' });

// "￥7,￥500,￥8,123,￥12"
```


---

## 🐘对象（Object）

---

## ⏰时间（Date）

### 1.基本使用

```js
new Date() // 创建一个时间对象 Fri Jul 12 2019 19:59:59 GMT+0800 (中国标准时间)

// 返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。
Date.now(); // 1562932828164

// 解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数
Date.parse('2019.7.12') // 1562860800000

// 年月日时分秒 获取
let dateMe = new Date()

dateMe.getFullYear() // 2019 | 根据本地时间返回指定日期的年份
dateMe.getMonth() // 6 | 根据本地时间，返回一个指定的日期对象的月份，为基于0的值（0表示一年中的第一月）。
dateMe.getDate() // 12 | 根据本地时间，返回一个指定的日期对象为一个月中的哪一日（从1--31）
dateMe.getHours() // 20 |根据本地时间，返回一个指定的日期对象的小时。
dateMe.getMinutes() // 11 | 根据本地时间，返回一个指定的日期对象的分钟数。
dateMe.getSeconds() // 29 | 方法根据本地时间，返回一个指定的日期对象的秒数
dateMe.getMilliseconds() // 363 | 根据本地时间，返回一个指定的日期对象的毫秒数。

dateMe.toJSON() // 🔥 "2019-07-12T12:05:15.363Z" | 返回 Date 对象的字符串形式
dateMe.getDay() // 5 | 根据本地时间，返回一个具体日期中一周的第几天，0 表示星期天（0 - 6）
dateMe.getTime() // 1562933115363 | 方法返回一个时间的格林威治时间数值。
dateMe.toString() // "Fri Jul 12 2019 20:05:15 GMT+0800 (中国标准时间)" | 返回一个字符串，表示该Date对象
dateMe.getTimezoneOffset() // -480（说明比正常时区慢480分钟，所以要加480分钟才对） | 返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。
dateMe.toDateString() // "Fri Jul 12 2019" | 以美式英语和人类易读的形式返回一个日期对象日期部分的字符串。

```

[MDN 更多详细](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date)

---

