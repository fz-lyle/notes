# 2.微信小程序

## 🐬第一部分：微信小程序核心理念，以及基础开发介绍

### 1.微信小程序核心理念介绍

---

### 2.微信小程序开发介绍

---

### 3.微信小程序目录结构介绍

---

### 🔥4.微信小程序基础配置介绍

---

## 🐳第二部分：WXML

**WXML用法上和HTML一样，就是标签（小程序里面是叫组件）名称不一样**

### 1.WXML基础

- WXML 全称 WeiXin Markup Language，是小程序设计的一套标签语言（虽然用法和HTML相似，但是不是HTML）
- 首先要明确一点，在小程序中书写 标签（或者叫组件），为什么能展示出来，是因为微信的渲染引擎和脚本引擎，经过一系列复杂的过程，最后呈现出来

```html

<!-- 小程序中没有div标签 -->
<view></view>

<!-- 小程序中没有p标签 -->
<text></text>

<!-- 小程序中没有 img标签 -->
<image></image>

<!-- ...... -->

```

---

### 2.组件共同属性

- id 组件标识，页面唯一
- class 类名
- style 内联样式
- hidden 是否隐藏
- data-* 自定义属性
- bind*/catch* 绑定事件

[更多...微信组件官方文档](https://developers.weixin.qq.com/miniprogram/dev/component/)

---

### 3.WXML数据绑定

**类似于Vue的 {{}}**

```html
<!-- index.wxml 页面（不是组件哦） -->
<block>

  <!-- 基础绑定 -->
  <text>{{name}}</text>
  <text class="{{className}}"></text>

  <!-- 基础运算 -->
  <text>{{ name === '朱昆鹏' ?  '三目运算测试成功' : '三目运算测试失败'}}</text>
  <text>{{ name + '，你好'}}</text>

  <!-- wx:if -->
  <view wx:if="{{ name === '朱昆鹏' }}">
    <text>名称是 朱昆鹏</text>
  </view>
  <view wx:elif=" name === '路人甲' ">
    <text>名称是 路人甲</text>
  </view>
  <view wx:else>
    <text>名称是 其他人</text>
  </view>

  <!-- wx:for, 下面那个block组件 就是为了for循环防止创建没用的组件 -->
  <block wx:for="{{ [1,2,3] }}"
        wx:for-index="index"
        wx:for-item="item"
        wx:key="index">
    {{index}} {{item}}
  </block>

</view>
```

```js
// index.js 页面的JS（不是组建的哦）

Page({

  // {{}} 里面解析的就是data里面的，但是这里没有像Vue一样返回一个新的对象，估计有自己的处理方式
  data: {
    name: '朱昆鹏',
    className: 'test'
  }

})
```

---

### 4.wx:if 和 hidden属性的差异

- wx:if 的渲染是惰性的，只有值是 true 的时候，微信引擎才会对里面的内容进行渲染
  - 渲染过程：切换 false 和 true 的时候，都会重新渲染
  - 适合比较稳定，不频繁切换的场景
- hidden属性，不管是 false还是 true，第一次的时候都会被引擎加载，存在我们的页面中
  - 渲染过程：由始至终只对组件渲染一次，即使切换隐藏和显示，组件其实不会销毁和创建
  - hidden初始化消耗资源多，适合频繁切换的场景

---

### 5.微信小程序 事件系统

- **注意：小程序的事件系统，可以设置是冒泡，还是捕获**
  - 冒泡：bind，例如 bind:tap（或者 bindtap）
  - 捕获：capture，例如 capture:tap（或者capturetap）


```html
<!-- index.wxml 页面 -->
<button data-name="朱昆鹏" 222="clickFun">按钮<button>

```

```js

// index.js 页面的JS

Page({

  data: {

  },

  onLoad: function () {

  },

  clickFun: function (e) {
    // 事件对象，常用的属性
    
    // e.target 用户触发的组件
    // e.target.dataset 组件上绑定的自定义数据 | 例如 e.target.dataset { name: 朱昆鹏 }

    // e.currentTarget 经过冒泡 响应的组件
    // e.currentTarget.dataset 和上面的一样

  }

})

```

- **常用事件分类**
  - tap 手指触摸后马上离开（就是点击）
  - touchstart 手指触摸动作开始（就是点击开始）
  - touchend 手指触摸动作结束（就是点击结束）
  - touchmove 手指触摸后移动（就是拖拽）
  - [更多请看...官方文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)
---


---

### 6.WXS

**为什么要有WXS**

- 小程序刚开始内测的时候是没有WXS，后来人们在使用过程中，发现了一个问题，就是优势互，数据和展示效果之间，可能要经过一些比较复杂的逻辑处理
  - 例如：数据是 1566739136513 一个时间戳，展示层要的效果是 2019-8-25 21点19分，这种的，小程序原有的 {{}} 写很多逻辑也不好，所以就有了WXS的出现
  - 备注：这个解决的问题，就相当于 Vue 中的计算属性

---

**WXS的使用（主要有三种,此处的使用，还需要举例）**

```js

// 1.写到WXML页面中


// 2.写成独立的WXML文件


// 3.写成WXS文件

// src属性引用
<wxs src="WXS文件相对路径" module="名称"></wxs>

// require函数引用
<wxs module="名称">
  let 名称 = reuquire('WXS文件相对路径')
  module.export.data = 名称.data
</wxs>

```

---


### 4.WXML实现原理解析



---

## 🐠第三部分：WXSS

### 1.WXSS基础

- **小程序的视图层是由 WXML 和 WXSS 进行编写，由微信框架组件进行展示**
- WXSS 不是 CSS哦，WXSS是微信定义的一套，修饰微信框架组件样式的规则

---

**小程序尺寸单位**

- rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
- 微信以iPhone6为依据，指定了rpx规则，其他和iPhone6手机大小不一致的，通够rpx进行转化，就能呈现出一样的效果了 

**拓展知识**

- 物理像素：Pixel
- 逻辑像素：PT/DP
- 像素密度：PPI
- 逻辑像素比：DPR

---

**微信小程序内联样式**

- 微信小程序中不能通过link来引入外部样式，只有 style内部样式 和 class类名，优先级和CSS一样
- important > style > #id > class

---

### 2.WXSS样式导入 和 选择器

**样式导入：使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束**

```css
@import "./css/common.wxss";
```

**微信小程序支持从CSS1 - CSS3的部分选择器**

---

### 3.全局样式和局部样式

- 小程序有全局样式和局部样式概念

```css

/* app.wxss 里面的代码作用全局，就是名称一样的话，会覆盖页面级wxss */

/* test.wxss 页面中的wxss，只作用于对应的页面 */

```

**❣️：WXSS无法加载本地文件（也就是如果要设置背景图的话，别用WXSS来设置本地的，要用网络上的，或者用内联样式）**

---

### 4.微信小程序布局（Flex）

**就是对于布局来说，WXSS完美支持Flex方案，建议好好学下，也不难，最核心的是下面这张图，要明白它的轴线，和交叉轴线的概念，其他的就是用了**

<img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" />

- 备注：[阮一峰Flex详细 链接](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)

---

### 5.WXSS原理分析

---

## 🔥第四部分：微信小程序基础组件

### 0.微信小程序组件绪论

- 微信的组件才是最重要的，因为我们所看到的视图，都是微信组件搭建的
- [更多...微信组件官方文档](https://developers.weixin.qq.com/miniprogram/dev/component/)

---

**使用组件**

```html
```


---

### 1.视图容器

```html

<!-- view：和div用法相似，没啥可说的 -->
<view></view>


<!-- swiper && swiper-item：滑块视图容器（就跟轮播图一样），有一些属性可以进行配置，例如下面的小点点啥的 -->
<swiper>
  <swiper-item>滑动项一</swiper-item>
  <swiper-item>滑动项二</swiper-item>
  <swiper-item>滑动项三</swiper-item>
</swiper>


<!-- scroll-view 可滚动视图区域。使用竖向滚动时，需要给scroll-view一个固定高度，通过 WXSS 设置 height。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px)。 -->
<scroll-view scroll-y style="height:200px;">
  <view style="height:100px;">1</view>
  <view style="height:100px;">2</view>
  <view style="height:100px;">3</view>
</scroll-view>


<!-- cover-view && cover-image 覆盖在原生组件之上的 原生组件，解决原生组件层级最高的问题 -->
<video>
  <!-- 覆盖在原生组件之上的文本视图 -->
  <cover-view>
    <!-- 覆盖在原生组件之上的图片视图。可覆盖的原生组件同cover-view，支持嵌套在cover-view里 -->
    <cover-image></cover-image>
  </cover-view>
</video>


<!-- movable-area && movable-view -->
<!-- movable-view的可移动区域 -->
<movable-area style="height: 200px; width: 200px; background: red;">
  <!-- 可移动的视图容器，在页面中可以拖拽滑动。movable-view必须在 movable-area 组件中，并且必须是直接子节点，否则不能移动 -->
  <movable-view direction="all" style="height: 50px; width: 50px; background: blue;"></movable-view>
</movable-area>

```

---

### 2.基础内容

```html

<!-- text：和p标签相似，没啥可说的 -->
<text></text>

<!-- icon：图标。组件属性的长度单位默认为px，2.4.0起支持传入单位(rpx/px) -->
<icon type="success"></icon>

<!-- progress：进度条 -->
<progress percent="80" active />

<!-- rich-text：富文本？ -->

```

---

### 3.表单组件

```html

<!-- button：按钮，不用多说 -->
<button></button>

<!-- input：输入框 该组件是原生组件，使用时请注意相关限制 -->
<input placeholder="这是一个可以自动聚焦的input" auto-focus/>

<!-- textarea：多行输入框 该组件是原生组件，使用时请注意相关限制 -->

<!-- radio：单选项目（单选框） -->

<!-- checkbox：多选项目（就是复选框） -->

<!-- switch：开关选择器（手机上常用的开关的形状） -->

<!-- 更多请看文档... -->

```

---

### 4.导航

```html

<!-- navigator：页面链接 -->
<navigator url="/pages/classic/classic">跳转到新页面</navigator>

<!-- functional-page-navigator：仅在插件中有效，用于跳转到插件功能页 -->

```

---

### 5.媒体组件

```html

<!-- image：图片组件，微信的这个组件封装了一些属性，让我们很方便的进行设置 -->
<image></image>

<!-- video：相关api：wx.createVideoContext -->
<video src="地址"></video>


<!-- camera：系统相机。扫码二维码功能，需升级微信客户端至6.7.3。需要用户授权 scope.camera。 -->

<!-- live-pusher：实时音视频录制 -->

<!-- live-player：实时音视频播放 -->

<!-- audio: 音频 1.6.0版本开始，该组件不再维护。建议使用能力更强的 wx.createInnerAudioContext 接口 -->

```

---

### 6.地图

**地图。相关api [wx.createMapContext](https://developers.weixin.qq.com/miniprogram/dev/api/media/map/wx.createMapContext.html)**

---

### 7.画布

**画布。相关api：[wx.createCanvasContext](https://developers.weixin.qq.com/miniprogram/dev/api/canvas/wx.createCanvasContext.html)**

---

### 8.原生组件 和 非原生组件

- 微信小程序，根据渲染类型不同可以分为两种
  - 基于WebView渲染的（基于浏览器渲染引擎渲染），我们称之为 **非原生组件**
  - 基于微信客户端渲染的，我们称之为 **原生组件**

- 非原生组件有
  - view
  - image
  - text
  - button
  - scroll-view
  - ...
- 原生组件有
  - camera
  - canvas
  - input（仅在focus时表现为原生组件）
  - live-player
  - live-pusher
  - map
  - textarea
  - video

---

**🔥 cover-view && cover-image 解决原生组件层级问题**

- 原生组件遇到最常见的问题，就是，无法在原生组件上添加东西，例如无法在地图map上添加东西，因为层级map一直是最高的
- 所以有了 cover-view 和 cover-image 来解决这个问题，这两个是原生组件，用来解决 原生组件层级最高的限制

---

**原生组件渲染流程**

- 先由WebView渲染一个占位元素（一个黑色的区域）
- 再调用微信客户端，跨线程通信，在刚刚的占位元素上，生成对应的原生组件（注意这里黑色的占位元素还未消失哦）

---

**原生组件和非原生组件的差异**

原生组件脱离在 WebView 渲染流程，会有一些问题，**原因是，跨线程的渲染机制，使我们组件之间数据，无法及时进行同步**

- 原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上
  - 后插入的原生组件可以覆盖之前的原生组件
- 原生组件还无法在 picker-view 中使用
  - 基础库 2.4.4 以下版本，原生组件不支持在 scroll-view、swiper、movable-view 中使用
  - 可以以后也可以在 picker-view 中使用了
- 部分CSS样式无法应用于原生组件
  - 无法对原生组件设置 CSS 动画
  - 无法定义原生组件为 position: fixed
  - 不能在父级节点使用 overflow: hidden 来裁剪原生组件的显示区域
- 原生组件的事件监听不能使用 bind:eventname 的写法，只支持 bindeventname。原生组件也不支持 catch 和 capture 的事件绑定方式
- 原生组件会遮挡 vConsole 弹出的调试面板。 在工具上，原生组件是用web组件模拟的，因此很多情况并不能很好的还原真机的表现，建议开发者在使用到原生组件时尽量在真机上进行调试

**❓ 为什么原生组件有这么多问题，微信还开发这么原生组件呢**

- 因为在视频解码，绘制地图，调用摄像头，调用键盘等等，有的是WebView有很差的性能问题，或者根本WebView就没办法实现，所以用微信客户端来渲染，就能很好的解决了

---

### 9.组件通信原理（了解即可）

**IOS的通信机制**

对于 IOS 系统来说，小程序的页面是呈现在 WKWebView 中的，WKWebView 初始化时，开发者会为其定义一系列的参数，而这些参数中，包含了一个方法 -addScriptMessageHandler，我们把它简称为 MessageHandler。MessageHandler 的主要功能，就是用于为 JavaScript 设置通讯的桥梁，多数情况下，我们可以认为它定义了 JavaScript 调用客户端的方法名称和接收传递的数据，并可监听客户端的事件消息。原生组件在 IOS 里，就是利用了这个特性实现与客户端通讯的。

**Andriod的通信机制**

不同于 IOS 的 MessageHandler 特性，在安卓系统里，小程序采用了 JavaScript 注入的方式，为 WebView 的 window 对象注入原生方法，并以类似于 JSBridge 的形式提供给开发者使用，包括调用（invoke）和监听（on）两种类型的方法，通过方法调用，可以通知客户端执行需要的方法并可传递不同的参数数据，而通过事件监听，可以获知组件的事件触发，从而实现了原生组件的通信。

**通信层级**

上面所讲到的机制，只是小程序页面与微信客户端之间的通信过程，但实际上，开发者大部份情况下并不会直接使用这些通信机制进行功能调用，更多的时候我们是间接地设置好组件，通过组件内部的实现，去使用客户端的原生功能。一般来说，原生组件在页面里定义好之后，在页面渲染阶段就会与客户端发生数据交互，通知客户端同步渲染组件内容。而在后续用户使用过程中，组件也会在必要时调用客户端接口对内容进行更新。

对于一些交互比较复杂的原生组件，小程序也会提供跟组件相关联的上下文对象，以便开发者可以在逻辑层中对组件进行操作。以 video 为例，小程序提供了 wx.createVideoContext 这个 API 来创建 video 的 context，以便在必要时可以控制视频的暂停、跳转、设置播放倍速等等。当然这些 API 也是经过一定的封装再提供给开发者的，我们并不能直接调用客户端的方法。

---

## 🐌第五部分：微信小程序API

---

## 🦀第六部分：微信小程序开放能力

---

## 🦋第七部分：组件化开发小程序


## 之前的内容，等待重构

### 一.小程序的基础知识与新特性

---

### 1.小程序的4种文件类型

- .wxml：骨架
- .wxss：样式
- .js：业务逻辑
- .json：配置

---

### 2.小程序的组织结构

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.notes/6.%E7%A7%BB%E5%8A%A8%E7%AB%AF/%E5%B0%8F%E7%A8%8B%E5%BA%8F/1.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84-1.png" />


---

### 3. app.json配置之导航栏


```
```

---

### 4.wxml与组件

- 小程序毕竟是微信的一个生态内容，所以只能用它所提供的组件，来搭建内容，而不能使用传统的HTML，但是大致的使用基本一致，就是切记这里不是HTML标签，而是组件，后期我们也能通过这个来拼接自己的组件

---

### 二.初识小程序组件

---

### 1.制作一个自定义组件

**定义组件：建立一个新的文件夹components 用来放组件，然后建立一个 like 文件夹，然后使用微信开发者工具快速生成目录**

**引用组件：在需要引入的页面的 .json文件中设置名称**

```json
{
  "usingComponents": {
    "z-like": "/components/like/index"
  }
}
```

**使用组件**

```html
<z-like></z-like>
<z-like></z-like>
<z-like></z-like>
```

---

**❣️ 绝对路径和相对路径**

```js
// /xxx 表示绝对路径，从根目录开始
// ../xxx 这种是相对路径，这个懂

```

---

### 2.like组件样式书写


**小程序尺寸单位和设计原则：rpx 可以自适应，px也有特定的使用场景**

**小程序的CSS选择器比文当中的多**

**🔥给所有页面都设置样式（相当于设置全局样式）**

```css
page {
  /* 苹果平方字体，细体，IOS默认字体，安卓默认是思源字体 */
  font-family: "PingFangSC-Thin";
}

/* ❣️：只有少量可以这样设置，生效的只有 font color */
```

**样式书写**

```html
<view class="container">
  <image src="./images/like.png"></image>
  <text>9</text>
</view>
```

```css
.container {
  /* 设置了flex，那么子元素是具有块级特性的，所以用 inline-flex 这样就具有行内块的特性了，子元素也就宽度自适应了 */
  display: inline-flex;
  flex-direction: row;
  padding: 10rpx;
}

.container image{
  width: 32rpx;
  height: 28rpx;
}

.container text {
  font-size: 24rpx;
  /* 组件最好不要有空白间距 */
  line-height: 24rpx;
  color: #bbb;
  position: relative;
  bottom: 10rpx;
  left: 6rpx;
}
```


---

### 3.组件的数据，事件，与属性

**数据绑定：和插值表达式基本一致,是写到js文件中的 data属性里面的**

- 同样可以应用在标签的属性中，而且不用像 Vue 一样加上 : ，不知道有没有 计算属性的写法，如下

```html
<view bindtap="onLike" class="container">
  <image src="{{like?yesSrc:noSrc}}"></image>
  <text>{{ count }}</text>
</view>

```

---

**组件的properties属性**

- 例如 like 组件的点赞数量，和 点赞的状态 是开放出来的，可以设置的，这个就需要用到 properties 来设置

```js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    like: {
      type: Boolean // 默认值是false,所以不用写默认值
      // value: false
    },
    count: {
      type: Number // 默认值是0
    }
  }

  // ...
})

// ❣️ 属性里面的内容，也能被插值表达式读取到，即使 data 中没有设置
```

---

```js
Component({
  /**
   * 组件的方法列表
   */
  methods: {

    // 点赞事件
    onLike: function (e) {

      let like = this.properties.like
      let count = this.properties.count

      like = !like
      like ? count+=1 : count-=1

      // 这里就不一样了，不是双向数据绑定，需要手动的通过 setData 来改变
      this.setData({
        like,
        count
      })

    }

  }
  // ...
})
```

---

### 三.访问API数据与ES6在小程序中的应用

### 1.生命周期函数

- 我们一般在 onLoad 生命周期中拿取数据，有点像 Vue的 mounted

---

### 2.wx.request

```js
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {

    // 获取最新一期的期刊
    wx.request({
      url: 'http://bl.7yue.pro/v1/classic/latest?appkey=EOYWLaUkKhvCc5Le',
      success: function (res) {
        console.log(res)
      }
    })

  },

```

---

**封装（utils/http.js）**

```js
// 提示信息
const tips = {
 1005: '秘钥不正确，请现申请',
 1007: '访问的地址不存在',
 3000: '期刊不存在'
}

const _showError = code => {
  return tips[code] || '其他默认错误'
}

export const zhuRequest = params => {

  return new Promise( (resovle, reject) => {

    wx.request({
      url: `http://bl.7yue.pro/v1${params.url}?appkey=EOYWLaUkKhvCc5Le`,
      method: params.method || 'GET',
      
      success(res) {

        let code = res.statusCode.toString()
        
        if (code.startsWith('2')) {
          resovle(res)
        } else {
          wx.showToast({
            title: _showError(res.data.error_code),
            icon: 'none'
          })
          reject(res)
        }

      },

      fail(rej) {
        reject(rej)
      }

    })

  })

}

```

---

**抽离出api层（/api/classic.js）**

```js
import { zhuRequest } from '../utils/http.js'

// 获取最新期刊
export const getNews = () => {
  return zhuRequest({
    url: '/classic/latest'
  })
}
```

---

**使用**


```js
import { getNews } from '../../api/classic.js'

Page({
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: async function (options) {
    
    // 获取所有期刊数据
    let resData = await getNews()
    console.log('数据：', resData)

  }

})

```

---

### 3.组件属性赋值与页面渲染

```js
import { getNews } from '../../api/classic.js'

Page({
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: async function (options) {
    
    // 获取所有期刊数据
    let resData = await getNews()

    this.setData({
      classicData: resData.data
    })
  
  }

})
```

```html
<!-- 使用 -->
<z-like count="{{classicData.fav_nums}}" like="{{classicData.like_status}}"></z-like>
```

**❣️ 只能通过 setData进行更新**

---

### 🔥4.自定义事件的激活和监听（父组件监听子组件事件）

```js
// like 子组件
Component({

  /**
   * 组件的方法列表
   */
  methods: {

    // 子组件点赞事件
    onLike: function (e) {

      let like = !this.properties.like
      let count = like ? this.properties.count += 1 : this.properties.count -= 1
      this.setData({like, count})

      // 响应到父组件上的 自定义事件
      let behavior = !this.properties.like ? 'like' : 'cancel'
      this.triggerEvent('like', {
        behavior: behavior
      }, {})

    }

  }
})

```

```js
// classic.wxml 使用
<z-like bind:like="onLike" count="{{classicData.fav_nums}}" like="{{classicData.like_status}}"></z-like>

Page({

  onLike: async function (e) {
    console.log('组件的事件', e)

    let behavior = e.detail.behavior
    let data = await like(behavior, this.data.classicData.id, this.data.classicData.type)

    console.log('数据：', data)

  },

  // ......
})
```

---

### 5.组件的生命周期函数

- 组件的声明周期，和页面的生命周期是两回事，这个没毛病，别整混了就行，这块遇到不常用的查下文档

---

### 6.observer函数的应用

**❣️❣️❣️ 千万不要在observer内部更改自己属性的值，会导致无限递归调用**

```js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    index: {
      type: Number,
      observer: function (newVal, oldVal) {
        let val = newVal < 10 ? `0${newVal}` : ''
        this.setData({
          _index: val // ❣️ 一种套路，但是这种情况下最好的解决方法是 wxs
        })
      }
    }
  },

  /**
   * 组件的初始数据
   */
  data: {
    year: 0,
    month: '',
    _index: ''
  },

  // ......
})
```

---

### 四.behavio行为与加入缓存系统

### 1.behavio行为（小程序组件的继承）

```js
// 定义
const classicBeh = Behavior({
    properties: {
        img: String,
        content: String,
        hidden:Boolean
    },
    attached:function(){

    },
    data:{

    },
    methods:{

    }
})

export {classicBeh}

```

```js
// 使用🔥

import { classicBeh } from '../classic-beh.js'

Component({

  // 继承
  behaviors: [classicBeh],

  /**
   * 组件的属性列表
   */
  properties: {
  },

  // ......
})
```


---

### 2.behavior 继承与多继承的覆盖规则

```js
// 这种写法，表示是支持多继承的
behaviors: [classicBeh, beh1, ...]

// 既然支持多继承，就有一个覆盖规则：
// 子组件中会覆盖继承的（自组件中的权级高
// 继承的生命周期函数，不会覆盖
```


---

### 3.小程序的缓存系统

```js
// 写入缓存
wx.setStorageSync('key名称', 变量) // 异步写入
wx.setStorage('key名称', 变量) // 同步写入

// 读取缓存
wx.getStorageSync('key名称') // 异步去读
wx.getStorage('key名称') // 同步去读
```

---

### 五.新版Music组件，组件通信，WXSS样式复用

### 1.如何让自定义组件支持hidden

- wx:if 的方式可以隐藏组件，但是 hidden 却隐藏不了我们自定义的组件，这个是为什么？
- 原因是小程序会认为这个可能是我们自己写的属性
- 解决方法：在组件中设置 hidden 属性，然后直接设置
- 为什么我们这里要用 hidden，因为如果要频繁的切换，用 hidden 比较好（具体可以看 wx:if vs hidden）

---

### 2.@import在组件中复用样式

- 直接定义一份 .wxss 文件（例如 common.wxss）

```css
/* 在需要的wxss文件中 引用 */
@import '../common.wxss';
```

---

### 3.组件间的通信

- 主要解决，音乐播放组件，一个播放其他的暂停，并且相互独立不影响，父子组件之间的通信比较好解决，但是兄弟组件之间的通信问题怎么解决呢
- 方案一：子组件先把数据发给 父组件 ，然后父组件再发给 目标子组件，这样实现兄弟组件之间的通信问题
- 方案二：组件消失的时候，暂停音乐


---

### 4. wx:for && wx:key

```js
// item表示每一项（也可以自定义值，但是一般不需要）
// 注意这里写的是 id 而不是 {{item.id}}
<block wx:key="id" wx:for="{{books}}">
  <z-book book="{{item}}"></z-book>
</block>
```

---

### 5.组件向页面传递数据

```js
// 组件中传递
Component({
  /**
   * 组件的方法列表
   */
  methods: {
    onTap: function (e) {
      const bid = this.properties.book.id
      wx.navigateTo({
        url: `/pages/book-detail/index?bid=${bid}`,
      })
    }
  }
  // ...
})


// 使用
Page({
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    console.log('options', options) // {bid: xxx}
  },

  // ...
})
```

---

### 6.组件设计思想：slot插槽的使用

```js
// 定义插槽 .wxml
<view class="container">
  <text>{{text}}</text>
  <!-- slot插槽 -->
  <slot name="after"></slot>
</view>

// 启动插槽 .js
Component({

  // 启动插槽
  options: {
    multipleSlots: true
  },

  // ...
})

// 🔥使用插槽
<z-tag text="{{item.content}}">
  <text class="num" slot="after">{{'+' + item.nums}}</text>
</z-tag>
```

---

### 7.自定义组件样式探讨：hack方式 && 外部样式的概念

- 我们没办法直接对自定义组件进行样式上的设置，如果我们了解我们写的组件的内部，那么就能用下面的方式来进行，有种hack的感觉

```css
.comment-container>v-tag:nth-child(1)>view {
    background-color: #fffbdd;
}

.comment-container>v-tag:nth-child(2)>view {
    background-color: #eefbff;
}
```

---

**🔥外部样式**

- JS传值，可以通过
- wxml传递，我们可以通过 slot 实现
- CSS传值通过？外部样式 externalClasses: []

```js
// 定义外部样式
Component({

  // 启动插槽
  options: {
    multipleSlots: true
  },

  // 定义外部样式
  externalClasses: ['tag-class'],

  // ...
})

// 定义
<view class="tag-class">
  <slot name="after"></slot>
</view>


// 使用（这里你发现，因为没有计算属性，所以需要些很长一段，下面可以通过wxs来进行优化）
<z-tag tag-class="{{index===0?'ex-tag1': '' || index===1?'ex-tag2':''}}" text="{{item.content}}">
</z-tag>

```

---

### 六.小程序wxs的应用

### 1.wxs的概念与应用（在我看来有些繁琐，没有计算属性好用）

- 我们之前想在 wxml 编写js或者调用js是不可能的，后来又了 wxs，有了这个就行了（有点像Vue的计算属性）

```js
// 定义（注意 WXS 不是 JavaScript，语法和 ES3类似，let const 都不能用）
var format =  function (text) {

  if (!text) {
    return
  }

  var reg = getRegExp('\\\\n', 'g')
  return text.replace(reg, '\n')
}

module.exports = {
  format: format
}

// 使用 /pages/book-detail/index.wxml
<wxs src="../../utils/filter.wxs" module="util" />

<text class="content">{{util.format(detail.summary)}}</text>
```

---

**也可以在 wxml 里面直接写 wxs**

```html
<wxs module="tool">
    var highlight = function(index){
        if(index==0){
            return 'ex-tag1'
        }
        if(index==1){
            return 'ex-tag2'
        }
        return ''
    }

    module.exports = {
        highlight:highlight
    }
</wxs>
```

---

### 2.开启加载状态（）

```js
Page({
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: async function (options) {
    
    wx.showLoading({
      title: '书籍详情加载中，请稍等',
    })

    const bid = options.bid

    // 做成并行发送最好
    // let resDetail = await getDetail(bid)
    // let resComment = await getComment(bid)
    // let resFavor = await getFavor(bid)

    // 并行
    let data = await Promise.all([getDetail(bid), getComment(bid), getFavor(bid)])
    let resDetail = data[0]
    let resComment = data[1]
    let resFavor = data[2]

    this.setData({
      detail: resDetail.data,
      comment: resComment.data,
      likeStatus: resFavor.data.like_status === 1,
      likeCount: resFavor.data.fav_nums
    })

    wx.hideLoading()
  },

  // ......
})
```

---



