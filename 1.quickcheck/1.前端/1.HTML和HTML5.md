# 1.HTML和HTML5

## 🌵常用的HTML标签，和常见的概念和用法

---

### 1.基础概念

**基础概念**

- 行内元素：与其他行内元素并排，不能设置宽高，默认的宽度就是文字的宽度
- 块级元素：独占一行，不能与其他任何元素并列。能接受宽高，如果不设置宽度，那么宽度将默认变为父级的100%
- 行内块元素：能设置宽高，与其他元素并排
- 相互转换：display：inline（block 块级 | inline-block 行内块）

**常见标签类型**

- 行内元素：a，span，textarea，select，input，b，br...
- 块级元素：div，h1~h6，ol，ul，p，hr，form，table ...
- 行内块元素：img...

---

### 2.HTML4.1 常用标签

---

### 3.HTML5语义化标签的用法

---

## 🎄Canvas

---

### 1.常见的canvas操作

**canvas基础结构**

```html
<body>
    
    <canvas id="canvas" width="500" height="500"></canvas>

    <script>
        // 获取指定的canvas元素
        let canvas = document.getElementById('canvas')
        // 调用canvas的 getctx 方法访问获取2d渲染上下文
        let ctx = canvas.getctx('2d')
        // 通过2d上下文执行绘画操作来绘制图形
        ctx.绘画操作();
        
    </script>

</body>
```

**canvas 绘制 路径（直线，三角形，圆弧，矩形等）**

```js

// 1.绘制直线
ctx.beginPath() // 开始创建新路径
ctx.moveTo(0, 0) // 路径原点
ctx.lineTo(50, 50) // 路径终点
ctx.stroke() // 输出路径轮廓

// 2.绘制三角形
ctx.beginPath() // 开始创建新路径
ctx.moveTo(0, 0) // 路径原点
ctx.lineTo(0, 100) // 路径终点
ctx.lineTo(100, 0) // 路径终点
ctx.closePath() // 自动闭合
ctx.fill() // 渲染路径轮廓（实心） | ctx.stroke()（渲染空心）

// 3.绘制圆形
ctx.beginPath(); // 开始创建新路径
ctx.arc(250, 250, 200, 0, 2 * Math.PI, false); // 设置开始角度为0，结束角度为 2π 弧度
ctx.fill(); // 使用 fill 自动闭合圆弧路径，然后填充圆弧区域

// 4.绘制矩形
ctx.strokeRect(0, 0, 50, 50) // 绘制矩形
ctx.fillRect(0, 100, 50, 50) // 绘制填充矩形

// 5.绘制圆角矩形
var x = 120; // 圆角矩形左上角横坐标
var y = 120; // 圆角矩形左上角纵坐标
var width = 250; // 圆角矩形的宽度
var height = 250; // 圆角矩形的高度
var radius = 50; // 圆角的半径

ctx.beginPath(); // 开始创建新路径
ctx.arc(x + radius, y + radius, radius, Math.PI, Math.PI * 3 / 2); // 绘制左上角圆角
ctx.lineTo(width - radius + x, y); // 绘制顶边路径
ctx.arc(width - radius + x, radius + y, radius, Math.PI * 3 / 2, Math.PI * 2); // 绘制右上角圆角
ctx.lineTo(width + x, height + y - radius); // 绘制右边路径
ctx.arc(width - radius + x, height - radius + y, radius, 0, Math.PI * 1 / 2); // 绘制右下角圆角
ctx.lineTo(radius + x, height +y); // 绘制底边路径
ctx.arc(radius + x, height - radius + y, radius, Math.PI * 1 / 2, Math.PI); // 绘制左下角圆角
ctx.closePath(); // 闭合路径 也可使用 ctx.lineTo(x, y + radius);
ctx.strokeStyle = '#188eee'; // 设置绘制的颜色
ctx.stroke(); // 渲染路径轮廓（空心）

```

**canvas绘制文本，以及设置属性**

```js

// 设置属性
ctx.fillStyle = 'red' // 设置填充颜色
ctx.strokeStyle = 'blue' // 设置填充颜色
ctx.lineWidth = 3 // 设置线条宽度
ctx.font = '60px 黑体'

// 绘制文本
ctx.strokeText('实心字体', 50, 100) // 空心的那种字体 | 后面两个参数是位置
ctx.fillText('描边字体', 50, 50) // 实心的那种字体

```

---

**擦除canvas**

```js
ctx.clearRect(x, y, 宽, 高) 
```

---

**canvas操作图片**

```js
// ctx.drawImage(image地址, x, y, [宽度], [高度])
let image = new Image()
image.src = '...'

image.onload = function () {
    // 因为图片加载是异步的，所以要写到回调中
    ctx.drawImage(image, 0, 0)
}
```


---

### 2.封装简单的canvas

**requestAnimationFrame封装canvas动画**

**canvas键盘事件封装**

**canvas碰撞检测封装**

**绘制特殊图形（贝塞尔曲线）**

---

## 🌲websocket

**基础使用**

```js

let socket = new WebSocket('ws://...') // 使用的是ws协议

// socket 完全打开并准备通信时候就会调用这个处理函数
socket.onpen = function () {

}

// socket 接收服务器消息
socket.onmessage = function (e) {

}

// 使用 postMessage() 向web服务发送一个消息
socket.postMessage('Hello Server')

```

---


## 🌳本地存储

**localStorage：每个浏览器都为本地存储提供了5MB~10MB的空间，除非主动删除，否则是不会消失的**

```js

// 存
localStorage.setItem('key', 'value')

// 取
localStorage.getItem('key')

// 属性
localStorage.length // 告诉我们localStorage有多少数据项
localStorage.key(i) // 传入index，可以拿到对象的数据（可以和length一起，做循环遍历）

// 方法
localStorage.removeItem(key) // 根据key值，清除对应的数据项
localStorage.clear() // 会删除当前页面关联的所有数据项
```

**sessionStorage：支持的API和上面完全相同，不同的地方在于，这个浏览器关闭之后，本地存储的数据项就会被删除**

---

## 🌴地理定位

```js

// navigator.geolocation.getCurrentPosition(成功回调，失败回调，配置参数)

navigator.geolocation.getCurrentPosition( res => {
    console.log('成功回调：', res)
    // res.coords.latitude 纬度
    // res.coords.longitude 经度
}, err => {
    console.log('失败回调：', err)
})

```

---

## 🌱HTML5视频标签（video）&& 音频标签（audio）

### 1.视频标签（video）

不再依赖第三方插件（Flash）

```html
<!-- 
    controls 浏览器会提供控件，允许用户控制视频和音频的播放
    autoplay自动播放
    poster="不播放视频时候显示的海报图片"
    loop 是否循环播放
    preload 更加细粒化的控制如何加载视频
    ...
-->
<video src="播放地址" controls autoplay poster="不播放视频时候显示的海报图片"></video>
```

```js

// 视频加载完成触发的回调
let video = document.getElementById('video')
video.addEventListener('ended', () => {
    // 回调触发
})

// ...
```

---

### 2.音频（audio元素）

---

## 🌿Web工作线程


---

## 🍃其他内容补充

### 1.Modernizer.js（检测浏览器对一个API的支持 | HTML5/CSS3检测库）

[Modernizer官方网址](https://modernizr.com/)
[Modernizer官方文档](https://modernizr.com/docs)

```js
// 示例
if (Modernizr.webgl){
    console.log('浏览器支持webgl')
} else {
    console.log('浏览器不支持webgl')
}
```

### 2.SVG


### 3.离线Web应用

**创建缓存清单文件（cache, manifest, file）**

```html
<!-- 将缓存清单文件的文件名加入到HTML标记中 -->
<html manifest="main.manifest">
```

**CACHE MANIFEST 必须以这个开头 | CACHE表示要缓存的文件**

```js
CACHE MANIFEST
CACHE:
main.html
main.css
main.js
```

**备注：如果在服务器上，还需要设置 AddType text/cache-manifest .manifest 这一行，用来提供正确的MIME类型**

